<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<!-- CUSTOMIZE THIS! -->
<title>TXM-Tutorial</title>
<meta name="author" content="Christof Schöch">
<!-- END -->
<meta name="description" content="Slides">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
<link rel="stylesheet" href="css/reveal.css">
<link rel="stylesheet" href="css/theme/simple.css" id="theme">
<!-- Code syntax highlighting -->
<link rel="stylesheet" href="lib/css/zenburn.css">
<!-- Printing and PDF exports -->
<script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>
<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>
<div class="reveal">
<!-- THIS IS WHERE THE CONTENT GOES! -->
<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section data-markdown>
<script type="text/template">
# TXM-Tutorial
<hr/>
<br/>
<br/>
<br/>
<p>Figurenbeschreibungsprojekt, Zoom, Juli 2020</p>
<br/>
<hr/>
<br/>
<p>Christof Schöch</p>
</script>
</section>

<section data-markdown>
<script type="text/template">
## Überblick
1. Einzelne Funktionen
2. Verschiedene Suchmodi
3. Erweiterte Suchen
4. Wildcards und Symbole
5. Strukturierung eines Korpus
6. Vergleichende Abfragen
</script>
</section>

<section>


<section data-markdown>
<script type="text/template">
## Textsammlungen als Beispiel
* ELTeC-fra: 100 franz. Romane: https://doi.org/10.5281/zenodo.3939542
* Textbox: 36 franz. Romane: https://doi.org/10.5281/zenodo.44547
* Conan Doyle: https://doi.org/10.5281/zenodo.802889
* Comédie humaine: https://doi.org/10.5281/zenodo.3747383
* Spanisch-amerikanische Romane (Ulrike Henny): https://doi.org/10.5281/zenodo.47218

</script>
</section>

<section data-markdown>
<script type="text/template">
## Tagsets von TreeTagger
* für Französisch und Spanisch
* Download: https://github.com/christofs/txm-tutorial/raw/gh-pages/TreeTagger_Tagsets_FR-ES.pdf
</script>
</section>


</section>
<section>
    
<section data-markdown>
<script type="text/template">
# 1. Einzelne Funktionen
</script>
</section>

<section data-markdown>
<script type="text/template">
## Lexique
Liste aller Wortformen, die im Korpus vorkommen, alphabetisch oder nach Frequenz sortierbar.
* Nützlich, um besonders häufige und besonders seltene Wörter festzustellen.
* Sortierbar nach Alphabet oder Frequenz
</script>
</section>

<section data-markdown>
<script type="text/template">
## Index
Abfrage der Frequenz einer bestimmten Wortform (oder anderer Suchbegriffe) im Korpus. 
* Man kann einstellen, welche Information als "pivot" (das im Zentrum stehende Element) angezeigt werden soll: die Wortform, das Lemma, oder das POS-Tag; oder mehrere dieser Informationen.
* Es werden die Treffer und ihre Frequenz angezeigt; man kann von hier aus weitere Sichten ansteuern (siehe unten)
</script>
</section>

<section data-markdown>
<script type="text/template">
## Concordance
Suche nach dem Kontext einer bestimmten Wortform (oder anderer Suchbegriffe). 
* Hier wird das Suchwort im Kontext angezeigt, also mit einigen Wörtern, die davor stehen und die folgen. Ganz links steht, in welchem Text der Treffer jeweils gefunden wurde. 
* Auch hier kann man einstellen, welche Informationen als "pivot" angezeigt werden sollen. Die Sortierung kann variiert werden. </script>
</section>

<section data-markdown>
<script type="text/template">
## Cooccurrences
Suche nach den Wortformen, die oft gemeinsam mit einer bestimmten Wortform vorkommen. Man kann nach verschiedenen Kriterien sortieren:
* `fréquence`: absolute Häufigkeit der kookurrierenden Wörter; abhängig von der Textlänge.
* `cofréquence`: absolute Häufigkeit, mit der das Suchwort und das gefundene Wort gemeinsam vorkommen. 
* `indice`: Maß für den Grad an Spezifik, den eine Kookurrenz von zwei Wörtern hat; dies ist die am stärksten aussagekräftige Angabe. 
* `distance`: durchschnittlicher Abstand zwischen dem Suchwort und dem gefundenen Wort im Textverlauf. 
* Kookkurrenz vs. Kollokation: https://www1.ids-mannheim.de/fileadmin/lexik/lehre/engelberg/Webseite_LingMeth/Skript_05.pdf
</script>
</section>


</section>
<section>


<section data-markdown>
<script type="text/template">
# 2. Verschiedene Suchmodi (Index)
</script>
</section>

<section data-markdown>
<script type="text/template">
## Wortformen
Suche nach graphischen Wortformen.
* `"happiness"`  - einfachste Variante; findet die Anzahl des Wortes, compare with `"detective"`, `"gun"`, `"murder"`
* `[word="happiness"]` - ebenso, aber diese Formulierung ist besser erweiterbar (siehe unten)</script>
</section>

<section data-markdown>
<script type="text/template">
## Lemmata
Suche nach allen Worten, die einer bestimmten Grundform zugehören. 
* `[enlemma="go"]` - hier werden alle Stellen gefunden, wo das Lemma "go" in verschiedenen Formen vorkommt: Wie z.B. "gone", "went", "going" usw.
* Klein- und Großschreibung wird hier ignoriert: "Go" wird also auch gefunden;
* (Sprachabhängig! `enlemma`, `frlemma`, `eslemma`, etc.)</script>
* `[frlemma="aller"]` – findet alle Stellen, an denen das Lemma "aller" in seinen verschiedenen Formen vorkommt: "allait" und "irons" etc.
</section>

<section data-markdown>
<script type="text/template">
## Part-of-Speech
Suche nach allen Wortformen, die einer bestimmten grammatikalischen Kategorie (POS) zugehören.
* `[enpos="NN"]` - findet die Substantive, sortiert nach ihren Häufigkeiten: "man", "hand", "face"
* `[enpos="JJ"]` - findet die Adjektive, wie "great", "old", "good"
* (Das Inventar der POS-Tags ist ebenfalls sprachabhängig)
</script>
* `[frpos="NOM"]` - Suche nach Substantiven. Findet "maison", "guerre", "crime", etc. 
* `[frpos="ADJ"]` – findet beliebige Adjektive: "grand", "élégant", etc. 
</section>

</section>
<section>

<section data-markdown>
<script type="text/template">
# 3. Erweiterte Suchen
</script>
</section>

<section data-markdown>
<script type="text/template">
## Folge mehrerer Suchbegriffe
Ein Suchbegriff, gefolgt von einem weiteren Suchbegriff.
* Solche Abfragen können mit dem Query Editor ("assistant de requêtes") erstellt werden; dort auf "mot supplémentaire" klicken.
* `[word="Sherlock"][word="Holmes"]` - gibt die Anzahl der Treffer zurück, wo "Sherlock" gefolgt vom "Holmes" vorkommt; 
* anderes Beispiel: `[word="Baker"][word="Street"]`
* Case-sensitive
Die verschiedenen Suchkombinationen sind möglich:
* `[enpos = "JJ"][enlemma="day"]`- Suche nach dem Lemma "day", das auf ein Adjektiv folgt.
</script>
* `[word="elle"][word="dit"]` – Findet die Anzahl der Stellen, an denen "elle dit" vorkommt.
Man kann hier auch verschiedene Suchmodi kombinieren: 
* `[frlemma="maison"][frpos="ADJ"]` - Findet Treffer, bei denen auf das Lemma "maison" ein Adjektiv folgt. Bspw.: "maison paternelle", "maison jaune" und "maisons basses".
</section>

<section data-markdown>
<script type="text/template">
## Suchbegriffe in bestimmtem Abstand
Mehrere Suchbegriffe, mit Minimal- und Maximalabstand dazwischen:
* `[enpos="V.*"][]{0,3}[enlemma="police"]`- findet alle Treffer eines Verbes, gefolgt  von dem Lemma "police" mit Abstand zwischen null und drei Worte
* z.B. werden folgende Wortkombinationen gefunden: "said the police", "communicated with the police", "known as the British police"
</script>
* `[frpos="VER.*"][]{0,5}[frlemma="argent"]` – Findet alle Kombinationen eines Verbs, gefolgt von null bis fünf anderen Worten, gefolgt von dem Lemma "argent"; 
* Beispielsweise: "dépense mon argent" und "avais beaucoup d'argent". 
</section>

<section data-markdown>
<script type="text/template">
## Kombination von Kriterien für ein Element
Verknüpfung von Kriterien unterschiedlicher Art bezogen auf ein einziges Element
* Bspw. Information über die Graphie eines Wortes mit seiner grammatikalischen Kategorie:
* `[word="break" & enpos="V.*"]` und `[word="break" & enpos="N.*"]` - im ersten Fall suchen wir nach "break" als Verb und 
im zweiten Fall nach "break", das als Substantiv verwendet wird;
</script>
*  `[word="marche" & frpos="VER.*"]` – Findet alle Wörter, die "marche" lauten UND ein Verb sind, d.h. schließt alle diejenigen Fälle aus, in denen "marche" als Substantiv verwendet wird.

</section>

</section>
<section>

<section data-markdown>
<script type="text/template">
# 4. Wildcards und Symbole
</script>
</section>

<section data-markdown>
<script type="text/template">
## Einige nützliche Wildcards: 
* `.` Punkt = jedes beliebige Wort-Zeichen (aber keine Leerzeichen etc.)
* `*` Stern = das direkt vorangehende Zeichen soll null mal oder beliebig oft auftauchen
* `+` Plus = das direkt vorangehende Zeichen soll mindestens einmal oder beliebig oft auftauchen
* `?` Fragezeichen = das direkt vorangehende Zeichen soll entweder null mal oder einmal auftauchen
</script>
</section>

<section data-markdown>
<script type="text/template">
## Beispielabfragen:
* `[word="to.?"]` - Wildcard innerhalb des Elements. Wort, das "to" und keinen oder einen weiterer Buchstabe hat; findet: "toi" und "ton", aber nicht "toit" (zwei weitere Buchstaben)
* `[word="f.*ique"]` – Wörter, die mit "f" anfangen, dann mehrere beliebige Zeichen haben und mit "ique" aufhören; findet: "fabrique", "fanatique" und "fantastique', etc.
* `[word=".*ique" & frpos="ADJ"]` – Wörter, die auf "ique" enden und Adjektive sind; findet: bspw. "unique", "magnifique" und "domestique", etc.
</script>
</section>

<section data-markdown>
<script type="text/template">
## Einige nützliche Symbole: 
* `{x}` Numerische Angabe: Gibt an, dass das vorangehende Zeichen oder Element genau x-mal vorkommen soll.
* `{x,y}` Numerischer Bereich: Gibt an, dass das vorangehende Zeichen oder Element zwischen x-mal und y-mal vorkommen soll.
* `%c` Zusatz nach den Anführungszeichen: die Groß- und Kleinschreibung wird ignoriert.
* `%d` Zusatz nach den Anführungszeichen: die Akzente und andere diakritischen Zeichen werden ignoriert. Kann auch als `%cd` kombiniert werden.</script>
</section>


<section data-markdown>
<script type="text/template">
## Beispielabfragen:
* `[word="dieu"%c]` – Ignoriert Groß- und Kleinschreibung; findet: "dieu" und "Dieu" sowie DIEU.
* `[word="la"][frpos="ADJ"]{2}[frpos="NOM"]` - Wildcard auf Ebene der Einheiten; Sequenzen, in denen erst das Wort "la" kommt, dann genau zwei Adjektive, dann ein Substantiv; findet bspw. "la pauvre jeune fille" oder "la douce petite voix". 
</script>
</section>

<section data-markdown>
<script type="text/template">
## Suche mit Alternativen
Mehrere Suchbegriffe alternativ suchen (mit dem "|"-Zeichen)
* `[word="ville|campagne"]` - Alternativen bezogen auf Einzelwörter; findet jeweils die Stellen, an denen "ville" oder "campagne" vorkommt. 
* `[frpos="DET:*|PRO.*"]` - Alternativen bezogen auf die Wortart; Suche nach Artikeln oder Personalpronomina; findet u.a. "il", "qui", "se", "vous", "je", etc.
</script>
</section>

</section>
<section>

<section data-markdown>
<script type="text/template">
# 5. Strukturierung eines Korpus
</script>
</section>

<section data-markdown>
<script type="text/template">
## Unter-Korpus definieren
Eine Teilmenge des Gesamtkorpus. 
* Rechts-Klick auf `ROMAN19`, dort `Sous-Corpus` auswählen. 
* Dem Unterkorpus einen Namen geben, bspw. "genres". 
* Im Reiter `simple` bleiben und die Einstellungen anpassen (Structure: `text` – Propriété: `subgenre`). 
* Aus der sich öffnenden Liste der Genres "historical" auswählen, OK klicken. 
* Für andere Kriterien das Vorgehen entsprechend anpassen oder die feiner zu steuernden Verfahren `assisté` oder `avancé` wählen.</script>
</section>

<section data-markdown>
<script type="text/template">
## Korpus partitionieren
Das Korpus intern strukturieren.
* Rechts-Klick auf `ROMAN19`, dort `Partition` auswählen. 
* Dem geteilten Korpus einen Namen geben, bspw. "Jahrzehnte". 
* Im Reiter `simple` bleiben und die Einstellungen passend einrichten: Structure: `text` – Propriété: `decades`). OK klicken.
* Hier wird Gesamtkorpus automatisch nach den relevanten Klassen aufgeteilt.
</script>
</section>

</section>
<section>

<section data-markdown>
<script type="text/template">
# 6. Vergleichende Abfragen</script>
</section>

<section data-markdown>
<script type="text/template">
## Progression
* Rechtsklick auf einen Treffer (in Index oder Lexique)
* Auf `Envoyer vers progression` klicken
* Type de graphe: `cumulatif` auswählen (zeigt die Trefferzahlen kumulativ, d.h. als ansteigende Kurve an; die Steigung der Kurve zeigt dann die lokale Frequenz an.)
* Échelle des bandeaux: "0.5" einstellen (oder zwischen 0.2 und 1.0 variieren)
* Unité strucurelle: `text` auswählen
* Propriété: `subgenre` oder `title` auswählen; OK klicken!</script>
</section>

<section data-markdown>
<script type="text/template">
## Spécificités
* Auf eine Partition klicken, dann Rechtsklick
* Auf `Spécificités` klicken
* Propriété definieren (bspw. `word`)
* `Focus de partie`: leer lassen für Vergleich aller Teile; oder einen Teil auswählen. OK klicken.
</script>
</section>


</section>
<section>

<section data-markdown>
<script type="text/template">
# 7. Datenimport</script>
</section>

<section data-markdown>
<script type="text/template">
## Binäres Korpus laden
* File > Load
* *.txm-Datei auswählen
* Fertig! 
</script>
</section>


<section data-markdown>
<script type="text/template">
## Plaintext-Korpus importieren
* File > Import > TXT+CSV
* Alle TXT-Dateien liegen in einem Ordner
* Wichtig: Datei "metadata.csv" (erste Spalte "id", Kommas als Separator)
* Annotation: setzt TreeTagger voraus (Installieren, Verlinken)
* Import laufen lassen
</script>
</section>








</section>

<section data-markdown>
<script type="text/template">
<br/>
<br/>
<br/>
<br/>
<p>Christof Schöch, 2016-2020</p>
<p>http://www.christof-schoech.de</p>
<hr/>
<p>Lizenz: Creative Commons Attribution 4.0 International</p>
<p>https://creativecommons.org/licenses/by/4.0/</p>
</script>
</section>




<!-- DON'T TOUCH UNLESS YOU KNOW WHAT YOU'RE DOING :-) -->
</div>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script>
// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: true,
    transition: 'slide', // none/fade/slide/convex/concave/zoom
    // Optional reveal.js plugins
    dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
        ]
    });
</script>
</body>
</html>
